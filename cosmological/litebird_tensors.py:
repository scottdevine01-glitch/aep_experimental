"""
AEP Tensor Mode Analysis for LiteBIRD
Tests the prediction r < 10^-4 with AEP systematic controls
"""

import math
import random

class AEPLitebirdAnalysis:
    """AEP-driven analysis of primordial gravitational waves"""
    
    def __init__(self):
        self.aep_predictions = {
            'r_max': 1e-4,  # 95% CL upper limit
            'r_central': 3e-5,  # Central prediction
            'sound_speed': 0.85,
            'dissipation_ratio': 0.4
        }
        
        # LiteBIRD specifications
        self.litebird_specs = {
            'sigma_r': 0.001,  # Sensitivity to r
            'delensing_efficiency': 0.6,
            'frequency_channels': 15,
            'launch_year': 2027
        }
        
        random.seed(42)
    
    def normal_distribution(self, mean=0, std=1):
        """Normal distribution generator"""
        u1 = random.random()
        u2 = random.random()
        return math.sqrt(-2.0 * math.log(u1)) * math.cos(2.0 * math.pi * u2) * std + mean
    
    def simulate_litebird_data(self):
        """Generate LiteBIRD-like B-mode measurements"""
        print("SIMULATING LITEBIRD B-MODE DATA")
        print("=" * 50)
        
        # Multipole bins
        l_bins = [10, 30, 50, 100, 150, 200]
        
        # AEP prediction: very small tensor signal
        r_true = self.aep_predictions['r_central']
        
        # Tensor B-mode spectrum (simplified)
        c_l_tensor = []
        for l in l_bins:
            # Reionization bump and recombination peak
            if l < 20:
                amplitude = 0.5  # Reionization bump
            elif l < 100:
                amplitude = 1.0  # Peak
            else:
                amplitude = 0.7  # Damping tail
            
            base_cl = amplitude * r_true * 1e-9
            c_l_tensor.append(base_cl)
        
        # LiteBIRD noise levels
        noise_levels = [2.0, 1.5, 1.2, 1.0, 1.1, 1.3]  # μK-arcmin equivalent
        
        measurements = []
        
        for i, l in enumerate(l_bins):
            # Signal + noise
            true_signal = c_l_tensor[i]
            noise = noise_levels[i] * 1e-9  # Scaled
            
            # Measurement with noise
            measured = true_signal + self.normal_distribution(0, noise)
            
            measurements.append({
                'l': l,
                'measured_cl': measured,
                'true_signal': true_signal,
                'noise_level': noise,
                'r_equivalent': measured / 1e-9  # Convert back to r units
            })
        
        print(f"Generated B-mode spectrum for {len(l_bins)} multipole bins")
        print(f"AEP tensor prediction: r = {r_true:.2e}")
        
        return measurements
    
    def aep_tensor_analysis(self, measurements):
        """AEP-driven tensor mode analysis"""
        print("\nAEP TENSOR MODE ANALYSIS")
        print("=" * 50)
        
        # Maximum likelihood estimation of r
        numerator = 0
        denominator = 0
        
        print("Multipole analysis:")
        print("l     C_l_meas    Noise    S/N")
        print("-" * 35)
        
        for meas in measurements:
            # Inverse variance weighting
            weight = 1.0 / (meas['noise_level'] ** 2)
            numerator += meas['measured_cl'] * weight
            denominator += weight
            
            # Signal-to-noise
            snr = meas['true_signal'] / meas['noise_level'] if meas['noise_level'] > 0 else 0
            
            print(f"{meas['l']:3d}  {meas['measured_cl']:8.2e}  {meas['noise_level']:8.2e}  {snr:5.2f}")
        
        # Best-fit r
        if denominator > 0:
            r_estimate = numerator / denominator / 1e-9  # Convert to r units
            statistical_error = 1.0 / math.sqrt(denominator) / 1e-9
        else:
            r_estimate = 0
            statistical_error = 1e-3
        
        print(f"\nTensor-to-scalar ratio estimate:")
        print(f"r = ({r_estimate:.2e}) ± ({statistical_error:.2e})")
        print(f"AEP prediction: r < {self.aep_predictions['r_max']:.0e} (95% CL)")
        
        return r_estimate, statistical_error
    
    def aep_systematic_control(self):
        """AEP complexity-based systematic error control for LiteBIRD"""
        print("\nAEP SYSTEMATIC CONTROL FOR LITEBIRD")
        print("=" * 50)
        
        systematics = [
            {'name': 'foreground_residual', 'amplitude': 0.5e-4, 'complexity': 12},
            {'name': 'beam_uncertainty', 'amplitude': 0.3e-4, 'complexity': 8},
            {'name': 'polarization_angle', 'amplitude': 0.2e-4, 'complexity': 6},
            {'name': 'delensing_residual', 'amplitude': 0.4e-4, 'complexity': 10},
        ]
        
        included = []
        total_systematic = 0
        
        print("AEP systematic evaluation:")
        for systematic in systematics:
            threshold = systematic['complexity'] / 300
            if systematic['amplitude'] > threshold:
                included.append(systematic)
                total_systematic += systematic['amplitude'] ** 2
                print(f"  ✓ {systematic['name']:20} ±{systematic['amplitude']:.1e}")
            else:
                print(f"  ✗ {systematic['name']:20} ±{systematic['amplitude']:.1e}")
        
        total_systematic = math.sqrt(total_systematic)
        print(f"Total systematic error: ±{total_systematic:.1e}")
        
        return total_systematic
    
    def aep_falsification_test(self, r_estimate, total_error):
        """AEP falsification test for tensor modes"""
        print("\nAEP FALSIFICATION TEST")
        print("=" * 50)
        
        # Combined uncertainty
        combined_error = total_error  # Statistical error already included in total_error
        
        # Upper limit calculation (95% CL)
        upper_limit = r_estimate + 2 * combined_error
        
        print(f"Measured r: {r_estimate:.2e} ± {combined_error:.2e}")
        print(f"95% CL upper limit: r < {upper_limit:.2e}")
        print(f"AEP falsification threshold: r > {self.aep_predictions['r_max']:.0e}")
        
        # Falsification condition
        if upper_limit > self.aep_predictions['r_max']:
            print("❌ AEP PREDICTION FALSIFIED")
            print("Tensor modes exceed AEP prediction")
            falsified = True
        else:
            print("✅ AEP PREDICTION CONSISTENT")
            print("Tensor modes within AEP limits")
            falsified = False
        
        return falsified, upper_limit
    
    def run_litebird_analysis(self):
        """Complete AEP LiteBIRD analysis pipeline"""
        print("AEP LITEBIRD TENSOR MODE ANALYSIS")
        print("=" * 60)
        print(f"AEP Prediction: r < {self.aep_predictions['r_max']:.0e} (95% CL)")
        print(f"LiteBIRD Sensitivity: σ(r) < {self.litebird_specs['sigma_r']:.0e}")
        print("=" * 60)
        
        # Generate simulated data
        measurements = self.simulate_litebird_data()
        
        # AEP tensor analysis
        r_estimate, statistical_error = self.aep_tensor_analysis(measurements)
        
        # AEP systematic control
        systematic_error = self.aep_systematic_control()
        
        # Combined error
        total_error = math.sqrt(statistical_error**2 + systematic_error**2)
        
        # Falsification test
        falsified, upper_limit = self.aep_falsification_test(r_estimate, total_error)
        
        # Final assessment
        print("\n" + "=" * 60)
        print("AEP LITEBIRD ANALYSIS COMPLETE")
        print("=" * 60)
        
        detection_significance = r_estimate / total_error if total_error > 0 else 0
        
        print(f"Final Results:")
        print(f"• r = ({r_estimate:.2e}) ± ({total_error:.2e})")
        print(f"• Detection significance: {detection_significance:.1f}σ")
        print(f"• 95% CL upper limit: r < {upper_limit:.2e}")
        
        if not falsified:
            print("✅ AEP TENSOR PREDICTION VALIDATED")
            conclusion = "VALIDATED"
        else:
            print("❌ AEP TENSOR PREDICTION FALSIFIED")
            conclusion = "FALSIFIED"
        
        return {
            'r_estimate': r_estimate,
            'total_error': total_error,
            'upper_limit': upper_limit,
            'detection_significance': detection_significance,
            'falsified': falsified,
            'conclusion': conclusion
        }

def main():
    """Run the AEP LiteBIRD analysis"""
    print("AEP LITEBIRD TENSOR MODE ANALYSIS")
    print("Testing predicted r < 10^-4 with AEP systematic controls\n")
    
    analyzer = AEPLitebirdAnalysis()
    results = analyzer.run_litebird_analysis()
    
    print(f"\nLiteBIRD Forecast Summary:")
    print(f"• AEP prediction: r < {analyzer.aep_predictions['r_max']:.0e}")
    print(f"• LiteBIRD sensitivity: σ(r) = {analyzer.litebird_specs['sigma_r']:.0e}")
    print(f"• Falsification potential: {'HIGH' if results['falsified'] else 'LOW'}")
    print(f"• Conclusion: {results['conclusion']}")

if __name__ == "__main__":
    main()
